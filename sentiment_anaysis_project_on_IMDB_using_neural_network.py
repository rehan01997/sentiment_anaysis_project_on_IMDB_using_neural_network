# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1skgmjvyoT_e4pvWD51Mc8mNCqGgRU1Wq
"""

import numpy as np
from keras.datasets import imdb

import numpy as np
# save np.load
np_load_old = np.load

# modify the default parameters of np.load
np.load = lambda *a,**k: np_load_old(*a, allow_pickle=True, **k)

# call load_data with allow_pickle implicitly set to true
(xT,yT), (xt,yt) = imdb.load_data(num_words=10000)

# restore np.load for future normal usage
np.load = np_load_old

print(xT.shape)

len(xt)

print(yt.shape)

word_idx=imdb.get_word_index()
print(word_idx.items())

idx_word=dict([value,key] for (key,value) in word_idx.items())
print(idx_word.items())

print(xt[0])

actual_review=" ".join([idx_word.get(idx-3,"#") for idx in xT[0]])
print(actual_review)

##vectoriszze
def vectorize_sentences(sentences,dim=10000):
  output=np.zeros((len(sentences),dim))
  for i,idx in enumerate(sentences):
    output[i,idx]=1
  return output

x_train=vectorize_sentences(xT)
x_test=vectorize_sentences(xt)

print(x_train[0])

y_train=np.asarray(yT).astype("float32")
y_test=np.asarray(yt).astype("float32")

print(y_train[0])

###build network
from keras import models
from keras.layers import Dense

model=models.Sequential()

model.compile(optimizer="rmsprop",loss="binary_crossentropy",metrics=["accuracy"])

model.add(Dense(16,activation="relu",input_shape=(10000,)))
model.add(Dense(16,activation="relu"))
model.add(Dense(1,activation="sigmoid"))



model.summary()

## avoid overfitting 

x_val=x_train[:5000]
xtrain_new=x_train[5000:]

y_val=y_train[:5000]
y_train_new=y_train[5000:]
print(x_val.shape)

hist=model.fit(xtrain_new,y_train_new,epochs=3,batch_size=512,validation_data=[x_val,y_val])

h=hist.history

import matplotlib.pyplot as plt
plt.plot(h['loss'],label="training loss")
plt.plot(h['val_loss'],label="validation loss")
plt.legend()
plt.show()

plt.plot(h['acc'],label="training accuracy")
plt.plot(h['val_acc'],label="validation acc")
plt.legend()
plt.show()

model.evaluate(x_test,y_test)

outputss=model.predict(x_test)
print(outputss)

oo=[]
for ele in outputss:
  if ele<=0.5:
    oo.append(0)
  else:
    oo.append(1)

oo=np.array(oo)
len(oo)

acc=np.sum(oo==y_test)/25000
print(acc)

